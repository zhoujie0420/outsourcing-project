{"ast":null,"code":"// src/normalize.ts\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      if (key === \"key\") return Reflect.get(target, key, receiver);\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\n\n// src/pick.ts\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  return path.slice(0, -1).reduce((obj, p) => {\n    if (/^(__proto__)$/.test(p)) return {};else return obj[p] = obj[p] || {};\n  }, state)[path[path.length - 1]] = val, state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce((substate, path) => {\n    const pathArray = path.split(\".\");\n    return set(substate, pathArray, get(baseState, pathArray));\n  }, {});\n}\n\n// src/plugin.ts\nfunction hydrateStore(store, {\n  storage,\n  serializer,\n  key,\n  debug\n}) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage) store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (error) {\n    if (debug) console.error(error);\n  }\n}\nfunction persistState(state, {\n  storage,\n  serializer,\n  key,\n  paths,\n  debug\n}) {\n  try {\n    const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n    storage.setItem(key, serializer.serialize(toStore));\n  } catch (error) {\n    if (debug) console.error(error);\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return context => {\n    const {\n      auto = false\n    } = factoryOptions;\n    const {\n      options: {\n        persist = auto\n      },\n      store,\n      pinia\n    } = context;\n    if (!persist) return;\n    if (!(store.$id in pinia.state.value)) {\n      const original_store = pinia._s.get(store.$id.replace(\"__hot:\", \"\"));\n      if (original_store) Promise.resolve().then(() => original_store.$persist());\n      return;\n    }\n    const persistences = (Array.isArray(persist) ? persist.map(p => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(({\n      storage = localStorage,\n      beforeRestore = null,\n      afterRestore = null,\n      serializer = {\n        serialize: JSON.stringify,\n        deserialize: JSON.parse\n      },\n      key = store.$id,\n      paths = null,\n      debug = false\n    }) => {\n      var _a;\n      return {\n        storage,\n        beforeRestore,\n        afterRestore,\n        serializer,\n        key: ((_a = factoryOptions.key) != null ? _a : k => k)(typeof key == \"string\" ? key : key(store.$id)),\n        paths,\n        debug\n      };\n    });\n    store.$persist = () => {\n      persistences.forEach(persistence => {\n        persistState(store.$state, persistence);\n      });\n    };\n    store.$hydrate = ({\n      runHooks = true\n    } = {}) => {\n      persistences.forEach(persistence => {\n        const {\n          beforeRestore,\n          afterRestore\n        } = persistence;\n        if (runHooks) beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, persistence);\n        if (runHooks) afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n    persistences.forEach(persistence => {\n      const {\n        beforeRestore,\n        afterRestore\n      } = persistence;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, persistence);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe((_mutation, state) => {\n        persistState(state, persistence);\n      }, {\n        detached: true\n      });\n    });\n  };\n}\n\n// src/index.ts\nvar src_default = createPersistedState();\nexport { createPersistedState, src_default as default };","map":{"version":3,"names":["isObject","v","normalizeOptions","options","factoryOptions","Object","create","Proxy","get","target","key","receiver","Reflect","state","path","reduce","obj","p","set","val","slice","test","length","pick","baseState","paths","substate","pathArray","split","hydrateStore","store","storage","serializer","debug","fromStorage","getItem","$patch","deserialize","error","console","persistState","toStore","Array","isArray","setItem","serialize","createPersistedState","context","auto","persist","pinia","$id","value","original_store","_s","replace","Promise","resolve","then","$persist","persistences","map","localStorage","beforeRestore","afterRestore","JSON","stringify","parse","_a","k","forEach","persistence","$state","$hydrate","runHooks","$subscribe","_mutation","detached","src_default","default"],"sources":["/Users/jiezhou/IdeaProjects/graduaction/sr_RemoteDoctor_2025/Front/node_modules/pinia-plugin-persistedstate/dist/index.mjs"],"sourcesContent":["// src/normalize.ts\nfunction isObject(v) {\n  return typeof v === \"object\" && v !== null;\n}\nfunction normalizeOptions(options, factoryOptions) {\n  options = isObject(options) ? options : /* @__PURE__ */ Object.create(null);\n  return new Proxy(options, {\n    get(target, key, receiver) {\n      if (key === \"key\")\n        return Reflect.get(target, key, receiver);\n      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);\n    }\n  });\n}\n\n// src/pick.ts\nfunction get(state, path) {\n  return path.reduce((obj, p) => {\n    return obj == null ? void 0 : obj[p];\n  }, state);\n}\nfunction set(state, path, val) {\n  return path.slice(0, -1).reduce((obj, p) => {\n    if (/^(__proto__)$/.test(p))\n      return {};\n    else\n      return obj[p] = obj[p] || {};\n  }, state)[path[path.length - 1]] = val, state;\n}\nfunction pick(baseState, paths) {\n  return paths.reduce((substate, path) => {\n    const pathArray = path.split(\".\");\n    return set(substate, pathArray, get(baseState, pathArray));\n  }, {});\n}\n\n// src/plugin.ts\nfunction hydrateStore(store, { storage, serializer, key, debug }) {\n  try {\n    const fromStorage = storage == null ? void 0 : storage.getItem(key);\n    if (fromStorage)\n      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));\n  } catch (error) {\n    if (debug)\n      console.error(error);\n  }\n}\nfunction persistState(state, { storage, serializer, key, paths, debug }) {\n  try {\n    const toStore = Array.isArray(paths) ? pick(state, paths) : state;\n    storage.setItem(key, serializer.serialize(toStore));\n  } catch (error) {\n    if (debug)\n      console.error(error);\n  }\n}\nfunction createPersistedState(factoryOptions = {}) {\n  return (context) => {\n    const { auto = false } = factoryOptions;\n    const {\n      options: { persist = auto },\n      store,\n      pinia\n    } = context;\n    if (!persist)\n      return;\n    if (!(store.$id in pinia.state.value)) {\n      const original_store = pinia._s.get(store.$id.replace(\"__hot:\", \"\"));\n      if (original_store)\n        Promise.resolve().then(() => original_store.$persist());\n      return;\n    }\n    const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(\n      ({\n        storage = localStorage,\n        beforeRestore = null,\n        afterRestore = null,\n        serializer = {\n          serialize: JSON.stringify,\n          deserialize: JSON.parse\n        },\n        key = store.$id,\n        paths = null,\n        debug = false\n      }) => {\n        var _a;\n        return {\n          storage,\n          beforeRestore,\n          afterRestore,\n          serializer,\n          key: ((_a = factoryOptions.key) != null ? _a : (k) => k)(typeof key == \"string\" ? key : key(store.$id)),\n          paths,\n          debug\n        };\n      }\n    );\n    store.$persist = () => {\n      persistences.forEach((persistence) => {\n        persistState(store.$state, persistence);\n      });\n    };\n    store.$hydrate = ({ runHooks = true } = {}) => {\n      persistences.forEach((persistence) => {\n        const { beforeRestore, afterRestore } = persistence;\n        if (runHooks)\n          beforeRestore == null ? void 0 : beforeRestore(context);\n        hydrateStore(store, persistence);\n        if (runHooks)\n          afterRestore == null ? void 0 : afterRestore(context);\n      });\n    };\n    persistences.forEach((persistence) => {\n      const { beforeRestore, afterRestore } = persistence;\n      beforeRestore == null ? void 0 : beforeRestore(context);\n      hydrateStore(store, persistence);\n      afterRestore == null ? void 0 : afterRestore(context);\n      store.$subscribe(\n        (_mutation, state) => {\n          persistState(state, persistence);\n        },\n        {\n          detached: true\n        }\n      );\n    });\n  };\n}\n\n// src/index.ts\nvar src_default = createPersistedState();\nexport {\n  createPersistedState,\n  src_default as default\n};\n"],"mappings":"AAAA;AACA,SAASA,QAAQA,CAACC,CAAC,EAAE;EACnB,OAAO,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,IAAI;AAC5C;AACA,SAASC,gBAAgBA,CAACC,OAAO,EAAEC,cAAc,EAAE;EACjDD,OAAO,GAAGH,QAAQ,CAACG,OAAO,CAAC,GAAGA,OAAO,GAAG,eAAgBE,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAC3E,OAAO,IAAIC,KAAK,CAACJ,OAAO,EAAE;IACxBK,GAAGA,CAACC,MAAM,EAAEC,GAAG,EAAEC,QAAQ,EAAE;MACzB,IAAID,GAAG,KAAK,KAAK,EACf,OAAOE,OAAO,CAACJ,GAAG,CAACC,MAAM,EAAEC,GAAG,EAAEC,QAAQ,CAAC;MAC3C,OAAOC,OAAO,CAACJ,GAAG,CAACC,MAAM,EAAEC,GAAG,EAAEC,QAAQ,CAAC,IAAIC,OAAO,CAACJ,GAAG,CAACJ,cAAc,EAAEM,GAAG,EAAEC,QAAQ,CAAC;IACzF;EACF,CAAC,CAAC;AACJ;;AAEA;AACA,SAASH,GAAGA,CAACK,KAAK,EAAEC,IAAI,EAAE;EACxB,OAAOA,IAAI,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAK;IAC7B,OAAOD,GAAG,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACC,CAAC,CAAC;EACtC,CAAC,EAAEJ,KAAK,CAAC;AACX;AACA,SAASK,GAAGA,CAACL,KAAK,EAAEC,IAAI,EAAEK,GAAG,EAAE;EAC7B,OAAOL,IAAI,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACL,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAK;IAC1C,IAAI,eAAe,CAACI,IAAI,CAACJ,CAAC,CAAC,EACzB,OAAO,CAAC,CAAC,CAAC,KAEV,OAAOD,GAAG,CAACC,CAAC,CAAC,GAAGD,GAAG,CAACC,CAAC,CAAC,IAAI,CAAC,CAAC;EAChC,CAAC,EAAEJ,KAAK,CAAC,CAACC,IAAI,CAACA,IAAI,CAACQ,MAAM,GAAG,CAAC,CAAC,CAAC,GAAGH,GAAG,EAAEN,KAAK;AAC/C;AACA,SAASU,IAAIA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAC9B,OAAOA,KAAK,CAACV,MAAM,CAAC,CAACW,QAAQ,EAAEZ,IAAI,KAAK;IACtC,MAAMa,SAAS,GAAGb,IAAI,CAACc,KAAK,CAAC,GAAG,CAAC;IACjC,OAAOV,GAAG,CAACQ,QAAQ,EAAEC,SAAS,EAAEnB,GAAG,CAACgB,SAAS,EAAEG,SAAS,CAAC,CAAC;EAC5D,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;;AAEA;AACA,SAASE,YAAYA,CAACC,KAAK,EAAE;EAAEC,OAAO;EAAEC,UAAU;EAAEtB,GAAG;EAAEuB;AAAM,CAAC,EAAE;EAChE,IAAI;IACF,MAAMC,WAAW,GAAGH,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACI,OAAO,CAACzB,GAAG,CAAC;IACnE,IAAIwB,WAAW,EACbJ,KAAK,CAACM,MAAM,CAACJ,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACK,WAAW,CAACH,WAAW,CAAC,CAAC;EACnF,CAAC,CAAC,OAAOI,KAAK,EAAE;IACd,IAAIL,KAAK,EACPM,OAAO,CAACD,KAAK,CAACA,KAAK,CAAC;EACxB;AACF;AACA,SAASE,YAAYA,CAAC3B,KAAK,EAAE;EAAEkB,OAAO;EAAEC,UAAU;EAAEtB,GAAG;EAAEe,KAAK;EAAEQ;AAAM,CAAC,EAAE;EACvE,IAAI;IACF,MAAMQ,OAAO,GAAGC,KAAK,CAACC,OAAO,CAAClB,KAAK,CAAC,GAAGF,IAAI,CAACV,KAAK,EAAEY,KAAK,CAAC,GAAGZ,KAAK;IACjEkB,OAAO,CAACa,OAAO,CAAClC,GAAG,EAAEsB,UAAU,CAACa,SAAS,CAACJ,OAAO,CAAC,CAAC;EACrD,CAAC,CAAC,OAAOH,KAAK,EAAE;IACd,IAAIL,KAAK,EACPM,OAAO,CAACD,KAAK,CAACA,KAAK,CAAC;EACxB;AACF;AACA,SAASQ,oBAAoBA,CAAC1C,cAAc,GAAG,CAAC,CAAC,EAAE;EACjD,OAAQ2C,OAAO,IAAK;IAClB,MAAM;MAAEC,IAAI,GAAG;IAAM,CAAC,GAAG5C,cAAc;IACvC,MAAM;MACJD,OAAO,EAAE;QAAE8C,OAAO,GAAGD;MAAK,CAAC;MAC3BlB,KAAK;MACLoB;IACF,CAAC,GAAGH,OAAO;IACX,IAAI,CAACE,OAAO,EACV;IACF,IAAI,EAAEnB,KAAK,CAACqB,GAAG,IAAID,KAAK,CAACrC,KAAK,CAACuC,KAAK,CAAC,EAAE;MACrC,MAAMC,cAAc,GAAGH,KAAK,CAACI,EAAE,CAAC9C,GAAG,CAACsB,KAAK,CAACqB,GAAG,CAACI,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;MACpE,IAAIF,cAAc,EAChBG,OAAO,CAACC,OAAO,CAAC,CAAC,CAACC,IAAI,CAAC,MAAML,cAAc,CAACM,QAAQ,CAAC,CAAC,CAAC;MACzD;IACF;IACA,MAAMC,YAAY,GAAG,CAAClB,KAAK,CAACC,OAAO,CAACM,OAAO,CAAC,GAAGA,OAAO,CAACY,GAAG,CAAE5C,CAAC,IAAKf,gBAAgB,CAACe,CAAC,EAAEb,cAAc,CAAC,CAAC,GAAG,CAACF,gBAAgB,CAAC+C,OAAO,EAAE7C,cAAc,CAAC,CAAC,EAAEyD,GAAG,CACvJ,CAAC;MACC9B,OAAO,GAAG+B,YAAY;MACtBC,aAAa,GAAG,IAAI;MACpBC,YAAY,GAAG,IAAI;MACnBhC,UAAU,GAAG;QACXa,SAAS,EAAEoB,IAAI,CAACC,SAAS;QACzB7B,WAAW,EAAE4B,IAAI,CAACE;MACpB,CAAC;MACDzD,GAAG,GAAGoB,KAAK,CAACqB,GAAG;MACf1B,KAAK,GAAG,IAAI;MACZQ,KAAK,GAAG;IACV,CAAC,KAAK;MACJ,IAAImC,EAAE;MACN,OAAO;QACLrC,OAAO;QACPgC,aAAa;QACbC,YAAY;QACZhC,UAAU;QACVtB,GAAG,EAAE,CAAC,CAAC0D,EAAE,GAAGhE,cAAc,CAACM,GAAG,KAAK,IAAI,GAAG0D,EAAE,GAAIC,CAAC,IAAKA,CAAC,EAAE,OAAO3D,GAAG,IAAI,QAAQ,GAAGA,GAAG,GAAGA,GAAG,CAACoB,KAAK,CAACqB,GAAG,CAAC,CAAC;QACvG1B,KAAK;QACLQ;MACF,CAAC;IACH,CACF,CAAC;IACDH,KAAK,CAAC6B,QAAQ,GAAG,MAAM;MACrBC,YAAY,CAACU,OAAO,CAAEC,WAAW,IAAK;QACpC/B,YAAY,CAACV,KAAK,CAAC0C,MAAM,EAAED,WAAW,CAAC;MACzC,CAAC,CAAC;IACJ,CAAC;IACDzC,KAAK,CAAC2C,QAAQ,GAAG,CAAC;MAAEC,QAAQ,GAAG;IAAK,CAAC,GAAG,CAAC,CAAC,KAAK;MAC7Cd,YAAY,CAACU,OAAO,CAAEC,WAAW,IAAK;QACpC,MAAM;UAAER,aAAa;UAAEC;QAAa,CAAC,GAAGO,WAAW;QACnD,IAAIG,QAAQ,EACVX,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAAChB,OAAO,CAAC;QACzDlB,YAAY,CAACC,KAAK,EAAEyC,WAAW,CAAC;QAChC,IAAIG,QAAQ,EACVV,YAAY,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACjB,OAAO,CAAC;MACzD,CAAC,CAAC;IACJ,CAAC;IACDa,YAAY,CAACU,OAAO,CAAEC,WAAW,IAAK;MACpC,MAAM;QAAER,aAAa;QAAEC;MAAa,CAAC,GAAGO,WAAW;MACnDR,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAAChB,OAAO,CAAC;MACvDlB,YAAY,CAACC,KAAK,EAAEyC,WAAW,CAAC;MAChCP,YAAY,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACjB,OAAO,CAAC;MACrDjB,KAAK,CAAC6C,UAAU,CACd,CAACC,SAAS,EAAE/D,KAAK,KAAK;QACpB2B,YAAY,CAAC3B,KAAK,EAAE0D,WAAW,CAAC;MAClC,CAAC,EACD;QACEM,QAAQ,EAAE;MACZ,CACF,CAAC;IACH,CAAC,CAAC;EACJ,CAAC;AACH;;AAEA;AACA,IAAIC,WAAW,GAAGhC,oBAAoB,CAAC,CAAC;AACxC,SACEA,oBAAoB,EACpBgC,WAAW,IAAIC,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}