{"ast":null,"code":"'use strict';\n\nvar support = require('./support');\nvar compressions = require('./compressions');\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function (str) {\n  var result = \"\";\n  for (var i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n  }\n  return result;\n};\nexports.arrayBuffer2Blob = function (buffer, mimeType) {\n  exports.checkSupport(\"blob\");\n  mimeType = mimeType || 'application/zip';\n  try {\n    // Blob constructor\n    return new Blob([buffer], {\n      type: mimeType\n    });\n  } catch (e) {\n    try {\n      // deprecated, browser only, old way\n      var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n      var builder = new Builder();\n      builder.append(buffer);\n      return builder.getBlob(mimeType);\n    } catch (e) {\n      // well, fuck ?!\n      throw new Error(\"Bug : can't construct the Blob.\");\n    }\n  }\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n  return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n  for (var i = 0; i < str.length; ++i) {\n    array[i] = str.charCodeAt(i) & 0xFF;\n  }\n  return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n  // Performances notes :\n  // --------------------\n  // String.fromCharCode.apply(null, array) is the fastest, see\n  // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n  // but the stack is limited (and we can get huge arrays !).\n  //\n  // result += String.fromCharCode(array[i]); generate too many strings !\n  //\n  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n  var chunk = 65536;\n  var result = [],\n    len = array.length,\n    type = exports.getTypeOf(array),\n    k = 0,\n    canUseApply = true;\n  try {\n    switch (type) {\n      case \"uint8array\":\n        String.fromCharCode.apply(null, new Uint8Array(0));\n        break;\n      case \"nodebuffer\":\n        String.fromCharCode.apply(null, nodeBuffer(0));\n        break;\n    }\n  } catch (e) {\n    canUseApply = false;\n  }\n\n  // no apply : slow and painful algorithm\n  // default browser on android 4.*\n  if (!canUseApply) {\n    var resultStr = \"\";\n    for (var i = 0; i < array.length; i++) {\n      resultStr += String.fromCharCode(array[i]);\n    }\n    return resultStr;\n  }\n  while (k < len && chunk > 1) {\n    try {\n      if (type === \"array\" || type === \"nodebuffer\") {\n        result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n      } else {\n        result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n      }\n      k += chunk;\n    } catch (e) {\n      chunk = Math.floor(chunk / 2);\n    }\n  }\n  return result.join(\"\");\n}\nexports.applyFromCharCode = arrayLikeToString;\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n  for (var i = 0; i < arrayFrom.length; i++) {\n    arrayTo[i] = arrayFrom[i];\n  }\n  return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n  \"string\": identity,\n  \"array\": function (input) {\n    return stringToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return transform[\"string\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return stringToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": function (input) {\n    return stringToArrayLike(input, nodeBuffer(input.length));\n  }\n};\n\n// array to ?\ntransform[\"array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": identity,\n  \"arraybuffer\": function (input) {\n    return new Uint8Array(input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(input);\n  }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n  \"string\": function (input) {\n    return arrayLikeToString(new Uint8Array(input));\n  },\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n  },\n  \"arraybuffer\": identity,\n  \"uint8array\": function (input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(new Uint8Array(input));\n  }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return input.buffer;\n  },\n  \"uint8array\": identity,\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(input);\n  }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function (outputType, input) {\n  if (!input) {\n    // undefined, null, etc\n    // an empty string won't harm.\n    input = \"\";\n  }\n  if (!outputType) {\n    return input;\n  }\n  exports.checkSupport(outputType);\n  var inputType = exports.getTypeOf(input);\n  var result = transform[inputType][outputType](input);\n  return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function (input) {\n  if (typeof input === \"string\") {\n    return \"string\";\n  }\n  if (Object.prototype.toString.call(input) === \"[object Array]\") {\n    return \"array\";\n  }\n  if (support.nodebuffer && nodeBuffer.test(input)) {\n    return \"nodebuffer\";\n  }\n  if (support.uint8array && input instanceof Uint8Array) {\n    return \"uint8array\";\n  }\n  if (support.arraybuffer && input instanceof ArrayBuffer) {\n    return \"arraybuffer\";\n  }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function (type) {\n  var supported = support[type.toLowerCase()];\n  if (!supported) {\n    throw new Error(type + \" is not supported by this browser\");\n  }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function (str) {\n  var res = '',\n    code,\n    i;\n  for (i = 0; i < (str || \"\").length; i++) {\n    code = str.charCodeAt(i);\n    res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n  }\n  return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function (compressionMethod) {\n  for (var method in compressions) {\n    if (!compressions.hasOwnProperty(method)) {\n      continue;\n    }\n    if (compressions[method].magic === compressionMethod) {\n      return compressions[method];\n    }\n  }\n  return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n  return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function () {\n  var result = {},\n    i,\n    attr;\n  for (i = 0; i < arguments.length; i++) {\n    // arguments is not enumerable in some browsers\n    for (attr in arguments[i]) {\n      if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n        result[attr] = arguments[i][attr];\n      }\n    }\n  }\n  return result;\n};","map":{"version":3,"names":["support","require","compressions","nodeBuffer","exports","string2binary","str","result","i","length","String","fromCharCode","charCodeAt","arrayBuffer2Blob","buffer","mimeType","checkSupport","Blob","type","e","Builder","window","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","builder","append","getBlob","Error","identity","input","stringToArrayLike","array","arrayLikeToString","chunk","len","getTypeOf","k","canUseApply","apply","Uint8Array","resultStr","push","slice","Math","min","subarray","floor","join","applyFromCharCode","arrayLikeToArrayLike","arrayFrom","arrayTo","transform","Array","arraybuffer","uint8array","nodebuffer","string","byteLength","transformTo","outputType","inputType","Object","prototype","toString","call","test","ArrayBuffer","supported","toLowerCase","MAX_VALUE_16BITS","MAX_VALUE_32BITS","pretty","res","code","toUpperCase","findCompression","compressionMethod","method","hasOwnProperty","magic","isRegExp","object","extend","attr","arguments"],"sources":["/Users/jiezhou/IdeaProjects/graduaction/zj/Front/node_modules/jszip/lib/utils.js"],"sourcesContent":["'use strict';\nvar support = require('./support');\nvar compressions = require('./compressions');\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function(str) {\n    var result = \"\";\n    for (var i = 0; i < str.length; i++) {\n        result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n    }\n    return result;\n};\nexports.arrayBuffer2Blob = function(buffer, mimeType) {\n    exports.checkSupport(\"blob\");\n\tmimeType = mimeType || 'application/zip';\n\n    try {\n        // Blob constructor\n        return new Blob([buffer], {\n            type: mimeType\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            return builder.getBlob(mimeType);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    var chunk = 65536;\n    var result = [],\n        len = array.length,\n        type = exports.getTypeOf(array),\n        k = 0,\n        canUseApply = true;\n      try {\n         switch(type) {\n            case \"uint8array\":\n               String.fromCharCode.apply(null, new Uint8Array(0));\n               break;\n            case \"nodebuffer\":\n               String.fromCharCode.apply(null, nodeBuffer(0));\n               break;\n         }\n      } catch(e) {\n         canUseApply = false;\n      }\n\n      // no apply : slow and painful algorithm\n      // default browser on android 4.*\n      if (!canUseApply) {\n         var resultStr = \"\";\n         for(var i = 0; i < array.length;i++) {\n            resultStr += String.fromCharCode(array[i]);\n         }\n    return resultStr;\n    }\n    while (k < len && chunk > 1) {\n        try {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        catch (e) {\n            chunk = Math.floor(chunk / 2);\n        }\n    }\n    return result.join(\"\");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodeBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodeBuffer.test(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this browser\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}