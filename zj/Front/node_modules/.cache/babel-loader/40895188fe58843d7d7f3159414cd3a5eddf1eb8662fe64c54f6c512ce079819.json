{"ast":null,"code":"'use strict';\n\nvar support = require('./support');\nvar utils = require('./utils');\nvar crc32 = require('./crc32');\nvar signature = require('./signature');\nvar defaults = require('./defaults');\nvar base64 = require('./base64');\nvar compressions = require('./compressions');\nvar CompressedObject = require('./compressedObject');\nvar nodeBuffer = require('./nodeBuffer');\nvar utf8 = require('./utf8');\nvar StringWriter = require('./stringWriter');\nvar Uint8ArrayWriter = require('./uint8ArrayWriter');\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getRawData = function (file) {\n  if (file._data instanceof CompressedObject) {\n    file._data = file._data.getContent();\n    file.options.binary = true;\n    file.options.base64 = false;\n    if (utils.getTypeOf(file._data) === \"uint8array\") {\n      var copy = file._data;\n      // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n      // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n      file._data = new Uint8Array(copy.length);\n      // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n      if (copy.length !== 0) {\n        file._data.set(copy, 0);\n      }\n    }\n  }\n  return file._data;\n};\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getBinaryData = function (file) {\n  var result = getRawData(file),\n    type = utils.getTypeOf(result);\n  if (type === \"string\") {\n    if (!file.options.binary) {\n      // unicode text !\n      // unicode string => binary string is a painful process, check if we can avoid it.\n      if (support.nodebuffer) {\n        return nodeBuffer(result, \"utf-8\");\n      }\n    }\n    return file.asBinary();\n  }\n  return result;\n};\n\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nvar dataToString = function (asUTF8) {\n  var result = getRawData(this);\n  if (result === null || typeof result === \"undefined\") {\n    return \"\";\n  }\n  // if the data is a base64 string, we decode it before checking the encoding !\n  if (this.options.base64) {\n    result = base64.decode(result);\n  }\n  if (asUTF8 && this.options.binary) {\n    // JSZip.prototype.utf8decode supports arrays as input\n    // skip to array => string step, utf8decode will do it.\n    result = out.utf8decode(result);\n  } else {\n    // no utf8 transformation, do the array => string step.\n    result = utils.transformTo(\"string\", result);\n  }\n  if (!asUTF8 && !this.options.binary) {\n    result = utils.transformTo(\"string\", out.utf8encode(result));\n  }\n  return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function (name, data, options) {\n  this.name = name;\n  this.dir = options.dir;\n  this.date = options.date;\n  this.comment = options.comment;\n  this.unixPermissions = options.unixPermissions;\n  this.dosPermissions = options.dosPermissions;\n  this._data = data;\n  this.options = options;\n\n  /*\n   * This object contains initial values for dir and date.\n   * With them, we can check if the user changed the deprecated metadata in\n   * `ZipObject#options` or not.\n   */\n  this._initialMetadata = {\n    dir: options.dir,\n    date: options.date\n  };\n};\nZipObject.prototype = {\n  /**\n   * Return the content as UTF8 string.\n   * @return {string} the UTF8 string.\n   */\n  asText: function () {\n    return dataToString.call(this, true);\n  },\n  /**\n   * Returns the binary content.\n   * @return {string} the content as binary.\n   */\n  asBinary: function () {\n    return dataToString.call(this, false);\n  },\n  /**\n   * Returns the content as a nodejs Buffer.\n   * @return {Buffer} the content as a Buffer.\n   */\n  asNodeBuffer: function () {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"nodebuffer\", result);\n  },\n  /**\n   * Returns the content as an Uint8Array.\n   * @return {Uint8Array} the content as an Uint8Array.\n   */\n  asUint8Array: function () {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"uint8array\", result);\n  },\n  /**\n   * Returns the content as an ArrayBuffer.\n   * @return {ArrayBuffer} the content as an ArrayBufer.\n   */\n  asArrayBuffer: function () {\n    return this.asUint8Array().buffer;\n  }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function (dec, bytes) {\n  var hex = \"\",\n    i;\n  for (i = 0; i < bytes; i++) {\n    hex += String.fromCharCode(dec & 0xff);\n    dec = dec >>> 8;\n  }\n  return hex;\n};\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nvar prepareFileAttrs = function (o) {\n  o = o || {};\n  if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n    o.binary = true;\n  }\n  o = utils.extend(o, defaults);\n  o.date = o.date || new Date();\n  if (o.compression !== null) o.compression = o.compression.toUpperCase();\n  return o;\n};\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function (name, data, o) {\n  // be sure sub folders exist\n  var dataType = utils.getTypeOf(data),\n    parent;\n  o = prepareFileAttrs(o);\n  if (typeof o.unixPermissions === \"string\") {\n    o.unixPermissions = parseInt(o.unixPermissions, 8);\n  }\n\n  // UNX_IFDIR  0040000 see zipinfo.c\n  if (o.unixPermissions && o.unixPermissions & 0x4000) {\n    o.dir = true;\n  }\n  // Bit 4    Directory\n  if (o.dosPermissions && o.dosPermissions & 0x0010) {\n    o.dir = true;\n  }\n  if (o.dir) {\n    name = forceTrailingSlash(name);\n  }\n  if (o.createFolders && (parent = parentFolder(name))) {\n    folderAdd.call(this, parent, true);\n  }\n  if (o.dir || data === null || typeof data === \"undefined\") {\n    o.base64 = false;\n    o.binary = false;\n    data = null;\n    dataType = null;\n  } else if (dataType === \"string\") {\n    if (o.binary && !o.base64) {\n      // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n      if (o.optimizedBinaryString !== true) {\n        // this is a string, not in a base64 format.\n        // Be sure that this is a correct \"binary string\"\n        data = utils.string2binary(data);\n      }\n    }\n  } else {\n    // arraybuffer, uint8array, ...\n    o.base64 = false;\n    o.binary = true;\n    if (!dataType && !(data instanceof CompressedObject)) {\n      throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n    }\n\n    // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n    if (dataType === \"arraybuffer\") {\n      data = utils.transformTo(\"uint8array\", data);\n    }\n  }\n  var object = new ZipObject(name, data, o);\n  this.files[name] = object;\n  return object;\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n  if (path.slice(-1) == '/') {\n    path = path.substring(0, path.length - 1);\n  }\n  var lastSlash = path.lastIndexOf('/');\n  return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n};\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function (path) {\n  // Check the name ends with a /\n  if (path.slice(-1) != \"/\") {\n    path += \"/\"; // IE doesn't like substr(-1)\n  }\n\n  return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function (name, createFolders) {\n  createFolders = typeof createFolders !== 'undefined' ? createFolders : false;\n  name = forceTrailingSlash(name);\n\n  // Does this folder already exist?\n  if (!this.files[name]) {\n    fileAdd.call(this, name, null, {\n      dir: true,\n      createFolders: createFolders\n    });\n  }\n  return this.files[name];\n};\n\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {JSZip.CompressedObject} the compressed result.\n */\nvar generateCompressedObjectFrom = function (file, compression, compressionOptions) {\n  var result = new CompressedObject(),\n    content;\n\n  // the data has not been decompressed, we might reuse things !\n  if (file._data instanceof CompressedObject) {\n    result.uncompressedSize = file._data.uncompressedSize;\n    result.crc32 = file._data.crc32;\n    if (result.uncompressedSize === 0 || file.dir) {\n      compression = compressions['STORE'];\n      result.compressedContent = \"\";\n      result.crc32 = 0;\n    } else if (file._data.compressionMethod === compression.magic) {\n      result.compressedContent = file._data.getCompressedContent();\n    } else {\n      content = file._data.getContent();\n      // need to decompress / recompress\n      result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n  } else {\n    // have uncompressed data\n    content = getBinaryData(file);\n    if (!content || content.length === 0 || file.dir) {\n      compression = compressions['STORE'];\n      content = \"\";\n    }\n    result.uncompressedSize = content.length;\n    result.crc32 = crc32(content);\n    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n  }\n  result.compressedSize = result.compressedContent.length;\n  result.compressionMethod = compression.magic;\n  return result;\n};\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n  var result = unixPermissions;\n  if (!unixPermissions) {\n    // I can't use octal values in strict mode, hence the hexa.\n    //  040775 => 0x41fd\n    // 0100664 => 0x81b4\n    result = isDir ? 0x41fd : 0x81b4;\n  }\n  return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n  // the dir flag is already set for compatibility\n\n  return (dosPermissions || 0) & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {object} the zip parts.\n */\nvar generateZipParts = function (name, file, compressedObject, offset, platform, encodeFileName) {\n  var data = compressedObject.compressedContent,\n    useCustomEncoding = encodeFileName !== utf8.utf8encode,\n    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n    comment = file.comment || \"\",\n    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n    o = file.options,\n    dosTime,\n    dosDate,\n    extraFields = \"\",\n    unicodePathExtraField = \"\",\n    unicodeCommentExtraField = \"\",\n    dir,\n    date;\n\n  // handle the deprecated options.dir\n  if (file._initialMetadata.dir !== file.dir) {\n    dir = file.dir;\n  } else {\n    dir = o.dir;\n  }\n\n  // handle the deprecated options.date\n  if (file._initialMetadata.date !== file.date) {\n    date = file.date;\n  } else {\n    date = o.date;\n  }\n  var extFileAttr = 0;\n  var versionMadeBy = 0;\n  if (dir) {\n    // dos or unix, we set the dos dir flag\n    extFileAttr |= 0x00010;\n  }\n  if (platform === \"UNIX\") {\n    versionMadeBy = 0x031E; // UNIX, version 3.0\n    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n  } else {\n    // DOS or other, fallback to DOS\n    versionMadeBy = 0x0014; // DOS, version 2.0\n    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n  }\n\n  // date\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n  dosTime = date.getHours();\n  dosTime = dosTime << 6;\n  dosTime = dosTime | date.getMinutes();\n  dosTime = dosTime << 5;\n  dosTime = dosTime | date.getSeconds() / 2;\n  dosDate = date.getFullYear() - 1980;\n  dosDate = dosDate << 4;\n  dosDate = dosDate | date.getMonth() + 1;\n  dosDate = dosDate << 5;\n  dosDate = dosDate | date.getDate();\n  if (useUTF8ForFileName) {\n    // set the unicode path extra field. unzip needs at least one extra\n    // field to correctly handle unicode path, so using the path is as good\n    // as any other information. This could improve the situation with\n    // other archive managers too.\n    // This field is usually used without the utf8 flag, with a non\n    // unicode path in the header (winrar, winzip). This helps (a bit)\n    // with the messy Windows' default compressed folders feature but\n    // breaks on p7zip which doesn't seek the unicode path extra field.\n    // So for now, UTF-8 everywhere !\n    unicodePathExtraField =\n    // Version\n    decToHex(1, 1) +\n    // NameCRC32\n    decToHex(crc32(encodedFileName), 4) +\n    // UnicodeName\n    utfEncodedFileName;\n    extraFields +=\n    // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x70\" +\n    // size\n    decToHex(unicodePathExtraField.length, 2) +\n    // content\n    unicodePathExtraField;\n  }\n  if (useUTF8ForComment) {\n    unicodeCommentExtraField =\n    // Version\n    decToHex(1, 1) +\n    // CommentCRC32\n    decToHex(this.crc32(encodedComment), 4) +\n    // UnicodeName\n    utfEncodedComment;\n    extraFields +=\n    // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x63\" +\n    // size\n    decToHex(unicodeCommentExtraField.length, 2) +\n    // content\n    unicodeCommentExtraField;\n  }\n  var header = \"\";\n\n  // version needed to extract\n  header += \"\\x0A\\x00\";\n  // general purpose bit flag\n  // set bit 11 if utf8\n  header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\";\n  // compression method\n  header += compressedObject.compressionMethod;\n  // last mod file time\n  header += decToHex(dosTime, 2);\n  // last mod file date\n  header += decToHex(dosDate, 2);\n  // crc-32\n  header += decToHex(compressedObject.crc32, 4);\n  // compressed size\n  header += decToHex(compressedObject.compressedSize, 4);\n  // uncompressed size\n  header += decToHex(compressedObject.uncompressedSize, 4);\n  // file name length\n  header += decToHex(encodedFileName.length, 2);\n  // extra field length\n  header += decToHex(extraFields.length, 2);\n  var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n  var dirRecord = signature.CENTRAL_FILE_HEADER +\n  // version made by (00: DOS)\n  decToHex(versionMadeBy, 2) +\n  // file header (common to file and central directory)\n  header +\n  // file comment length\n  decToHex(encodedComment.length, 2) +\n  // disk number start\n  \"\\x00\\x00\" +\n  // internal file attributes TODO\n  \"\\x00\\x00\" +\n  // external file attributes\n  decToHex(extFileAttr, 4) +\n  // relative offset of local header\n  decToHex(offset, 4) +\n  // file name\n  encodedFileName +\n  // extra field\n  extraFields +\n  // file comment\n  encodedComment;\n  return {\n    fileRecord: fileRecord,\n    dirRecord: dirRecord,\n    compressedObject: compressedObject\n  };\n};\n\n// return the actual prototype of JSZip\nvar out = {\n  /**\n   * Read an existing zip and merge the data in the current JSZip object.\n   * The implementation is in jszip-load.js, don't forget to include it.\n   * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n   * @param {Object} options Options for loading the stream.\n   *  options.base64 : is the stream in base64 ? default : false\n   * @return {JSZip} the current JSZip object\n   */\n  load: function (stream, options) {\n    throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n  },\n  /**\n   * Filter nested files/folders with the specified function.\n   * @param {Function} search the predicate to use :\n   * function (relativePath, file) {...}\n   * It takes 2 arguments : the relative path and the file.\n   * @return {Array} An array of matching elements.\n   */\n  filter: function (search) {\n    var result = [],\n      filename,\n      relativePath,\n      file,\n      fileClone;\n    for (filename in this.files) {\n      file = this.files[filename];\n      // return a new object, don't let the user mess with our internal objects :)\n      fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));\n      relativePath = filename.slice(this.root.length, filename.length);\n      if (filename.slice(0, this.root.length) === this.root &&\n      // the file is in the current root\n      search(relativePath, fileClone)) {\n        // and the file matches the function\n        result.push(fileClone);\n      }\n    }\n    return result;\n  },\n  /**\n   * Add a file to the zip file, or search a file.\n   * @param   {string|RegExp} name The name of the file to add (if data is defined),\n   * the name of the file to find (if no data) or a regex to match files.\n   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n   * @param   {Object} o     File options\n   * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n   * a file (when searching by string) or an array of files (when searching by regex).\n   */\n  file: function (name, data, o) {\n    if (arguments.length === 1) {\n      if (utils.isRegExp(name)) {\n        var regexp = name;\n        return this.filter(function (relativePath, file) {\n          return !file.dir && regexp.test(relativePath);\n        });\n      } else {\n        // text\n        return this.filter(function (relativePath, file) {\n          return !file.dir && relativePath === name;\n        })[0] || null;\n      }\n    } else {\n      // more than one argument : we have data !\n      name = this.root + name;\n      fileAdd.call(this, name, data, o);\n    }\n    return this;\n  },\n  /**\n   * Add a directory to the zip file, or search.\n   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n   * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n   */\n  folder: function (arg) {\n    if (!arg) {\n      return this;\n    }\n    if (utils.isRegExp(arg)) {\n      return this.filter(function (relativePath, file) {\n        return file.dir && arg.test(relativePath);\n      });\n    }\n\n    // else, name is a new folder\n    var name = this.root + arg;\n    var newFolder = folderAdd.call(this, name);\n\n    // Allow chaining by returning a new object with this folder as the root\n    var ret = this.clone();\n    ret.root = newFolder.name;\n    return ret;\n  },\n  /**\n   * Delete a file, or a directory and all sub-files, from the zip\n   * @param {string} name the name of the file to delete\n   * @return {JSZip} this JSZip object\n   */\n  remove: function (name) {\n    name = this.root + name;\n    var file = this.files[name];\n    if (!file) {\n      // Look for any folders\n      if (name.slice(-1) != \"/\") {\n        name += \"/\";\n      }\n      file = this.files[name];\n    }\n    if (file && !file.dir) {\n      // file\n      delete this.files[name];\n    } else {\n      // maybe a folder, delete recursively\n      var kids = this.filter(function (relativePath, file) {\n        return file.name.slice(0, name.length) === name;\n      });\n      for (var i = 0; i < kids.length; i++) {\n        delete this.files[kids[i].name];\n      }\n    }\n    return this;\n  },\n  /**\n   * Generate the complete zip file\n   * @param {Object} options the options to generate the zip file :\n   * - base64, (deprecated, use type instead) true to generate base64.\n   * - compression, \"STORE\" by default.\n   * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n   */\n  generate: function (options) {\n    options = utils.extend(options || {}, {\n      base64: true,\n      compression: \"STORE\",\n      compressionOptions: null,\n      type: \"base64\",\n      platform: \"DOS\",\n      comment: null,\n      mimeType: 'application/zip',\n      encodeFileName: utf8.utf8encode\n    });\n    utils.checkSupport(options.type);\n\n    // accept nodejs `process.platform`\n    if (options.platform === 'darwin' || options.platform === 'freebsd' || options.platform === 'linux' || options.platform === 'sunos') {\n      options.platform = \"UNIX\";\n    }\n    if (options.platform === 'win32') {\n      options.platform = \"DOS\";\n    }\n    var zipData = [],\n      localDirLength = 0,\n      centralDirLength = 0,\n      writer,\n      i,\n      encodedComment = utils.transformTo(\"string\", options.encodeFileName(options.comment || this.comment || \"\"));\n\n    // first, generate all the zip parts.\n    for (var name in this.files) {\n      var file = this.files[name];\n      var compressionName = file.options.compression || options.compression.toUpperCase();\n      var compression = compressions[compressionName];\n      if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n      }\n      var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n      var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n      var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);\n      localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n      centralDirLength += zipPart.dirRecord.length;\n      zipData.push(zipPart);\n    }\n    var dirEnd = \"\";\n\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END +\n    // number of this disk\n    \"\\x00\\x00\" +\n    // number of the disk with the start of the central directory\n    \"\\x00\\x00\" +\n    // total number of entries in the central directory on this disk\n    decToHex(zipData.length, 2) +\n    // total number of entries in the central directory\n    decToHex(zipData.length, 2) +\n    // size of the central directory   4 bytes\n    decToHex(centralDirLength, 4) +\n    // offset of start of central directory with respect to the starting disk number\n    decToHex(localDirLength, 4) +\n    // .ZIP file comment length\n    decToHex(encodedComment.length, 2) +\n    // .ZIP file comment\n    encodedComment;\n\n    // we have all the parts (and the total length)\n    // time to create a writer !\n    var typeName = options.type.toLowerCase();\n    if (typeName === \"uint8array\" || typeName === \"arraybuffer\" || typeName === \"blob\" || typeName === \"nodebuffer\") {\n      writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n    } else {\n      writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n    }\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].fileRecord);\n      writer.append(zipData[i].compressedObject.compressedContent);\n    }\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].dirRecord);\n    }\n    writer.append(dirEnd);\n    var zip = writer.finalize();\n    switch (options.type.toLowerCase()) {\n      // case \"zip is an Uint8Array\"\n      case \"uint8array\":\n      case \"arraybuffer\":\n      case \"nodebuffer\":\n        return utils.transformTo(options.type.toLowerCase(), zip);\n      case \"blob\":\n        return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip), options.mimeType);\n      // case \"zip is a string\"\n      case \"base64\":\n        return options.base64 ? base64.encode(zip) : zip;\n      default:\n        // case \"string\" :\n        return zip;\n    }\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  crc32: function (input, crc) {\n    return crc32(input, crc);\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8encode: function (string) {\n    return utils.transformTo(\"string\", utf8.utf8encode(string));\n  },\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8decode: function (input) {\n    return utf8.utf8decode(input);\n  }\n};\nmodule.exports = out;","map":{"version":3,"names":["support","require","utils","crc32","signature","defaults","base64","compressions","CompressedObject","nodeBuffer","utf8","StringWriter","Uint8ArrayWriter","getRawData","file","_data","getContent","options","binary","getTypeOf","copy","Uint8Array","length","set","getBinaryData","result","type","nodebuffer","asBinary","dataToString","asUTF8","decode","out","utf8decode","transformTo","utf8encode","ZipObject","name","data","dir","date","comment","unixPermissions","dosPermissions","_initialMetadata","prototype","asText","call","asNodeBuffer","asUint8Array","asArrayBuffer","buffer","decToHex","dec","bytes","hex","i","String","fromCharCode","prepareFileAttrs","o","undefined","extend","Date","compression","toUpperCase","fileAdd","dataType","parent","parseInt","forceTrailingSlash","createFolders","parentFolder","folderAdd","optimizedBinaryString","string2binary","Error","object","files","path","slice","substring","lastSlash","lastIndexOf","generateCompressedObjectFrom","compressionOptions","content","uncompressedSize","compressedContent","compressionMethod","magic","getCompressedContent","compress","compressInputType","compressedSize","generateUnixExternalFileAttr","isDir","generateDosExternalFileAttr","generateZipParts","compressedObject","offset","platform","encodeFileName","useCustomEncoding","encodedFileName","utfEncodedFileName","encodedComment","utfEncodedComment","useUTF8ForFileName","useUTF8ForComment","dosTime","dosDate","extraFields","unicodePathExtraField","unicodeCommentExtraField","extFileAttr","versionMadeBy","getHours","getMinutes","getSeconds","getFullYear","getMonth","getDate","header","fileRecord","LOCAL_FILE_HEADER","dirRecord","CENTRAL_FILE_HEADER","load","stream","filter","search","filename","relativePath","fileClone","root","push","arguments","isRegExp","regexp","test","folder","arg","newFolder","ret","clone","remove","kids","generate","mimeType","checkSupport","zipData","localDirLength","centralDirLength","writer","compressionName","zipPart","dirEnd","CENTRAL_DIRECTORY_END","typeName","toLowerCase","append","zip","finalize","arrayBuffer2Blob","encode","input","crc","string","module","exports"],"sources":["/Users/jiezhou/IdeaProjects/graduaction/zj/Front/node_modules/jszip/lib/object.js"],"sourcesContent":["'use strict';\nvar support = require('./support');\nvar utils = require('./utils');\nvar crc32 = require('./crc32');\nvar signature = require('./signature');\nvar defaults = require('./defaults');\nvar base64 = require('./base64');\nvar compressions = require('./compressions');\nvar CompressedObject = require('./compressedObject');\nvar nodeBuffer = require('./nodeBuffer');\nvar utf8 = require('./utf8');\nvar StringWriter = require('./stringWriter');\nvar Uint8ArrayWriter = require('./uint8ArrayWriter');\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getRawData = function(file) {\n    if (file._data instanceof CompressedObject) {\n        file._data = file._data.getContent();\n        file.options.binary = true;\n        file.options.base64 = false;\n\n        if (utils.getTypeOf(file._data) === \"uint8array\") {\n            var copy = file._data;\n            // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n            // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n            file._data = new Uint8Array(copy.length);\n            // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n            if (copy.length !== 0) {\n                file._data.set(copy, 0);\n            }\n        }\n    }\n    return file._data;\n};\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getBinaryData = function(file) {\n    var result = getRawData(file),\n        type = utils.getTypeOf(result);\n    if (type === \"string\") {\n        if (!file.options.binary) {\n            // unicode text !\n            // unicode string => binary string is a painful process, check if we can avoid it.\n            if (support.nodebuffer) {\n                return nodeBuffer(result, \"utf-8\");\n            }\n        }\n        return file.asBinary();\n    }\n    return result;\n};\n\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nvar dataToString = function(asUTF8) {\n    var result = getRawData(this);\n    if (result === null || typeof result === \"undefined\") {\n        return \"\";\n    }\n    // if the data is a base64 string, we decode it before checking the encoding !\n    if (this.options.base64) {\n        result = base64.decode(result);\n    }\n    if (asUTF8 && this.options.binary) {\n        // JSZip.prototype.utf8decode supports arrays as input\n        // skip to array => string step, utf8decode will do it.\n        result = out.utf8decode(result);\n    }\n    else {\n        // no utf8 transformation, do the array => string step.\n        result = utils.transformTo(\"string\", result);\n    }\n\n    if (!asUTF8 && !this.options.binary) {\n        result = utils.transformTo(\"string\", out.utf8encode(result));\n    }\n    return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this.options = options;\n\n    /*\n     * This object contains initial values for dir and date.\n     * With them, we can check if the user changed the deprecated metadata in\n     * `ZipObject#options` or not.\n     */\n    this._initialMetadata = {\n      dir : options.dir,\n      date : options.date\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Return the content as UTF8 string.\n     * @return {string} the UTF8 string.\n     */\n    asText: function() {\n        return dataToString.call(this, true);\n    },\n    /**\n     * Returns the binary content.\n     * @return {string} the content as binary.\n     */\n    asBinary: function() {\n        return dataToString.call(this, false);\n    },\n    /**\n     * Returns the content as a nodejs Buffer.\n     * @return {Buffer} the content as a Buffer.\n     */\n    asNodeBuffer: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"nodebuffer\", result);\n    },\n    /**\n     * Returns the content as an Uint8Array.\n     * @return {Uint8Array} the content as an Uint8Array.\n     */\n    asUint8Array: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"uint8array\", result);\n    },\n    /**\n     * Returns the content as an ArrayBuffer.\n     * @return {ArrayBuffer} the content as an ArrayBufer.\n     */\n    asArrayBuffer: function() {\n        return this.asUint8Array().buffer;\n    }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\",\n        i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nvar prepareFileAttrs = function(o) {\n    o = o || {};\n    if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n        o.binary = true;\n    }\n    o = utils.extend(o, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) o.compression = o.compression.toUpperCase();\n\n    return o;\n};\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, o) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n    o = prepareFileAttrs(o);\n\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    if (o.dir || data === null || typeof data === \"undefined\") {\n        o.base64 = false;\n        o.binary = false;\n        data = null;\n        dataType = null;\n    }\n    else if (dataType === \"string\") {\n        if (o.binary && !o.base64) {\n            // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n            if (o.optimizedBinaryString !== true) {\n                // this is a string, not in a base64 format.\n                // Be sure that this is a correct \"binary string\"\n                data = utils.string2binary(data);\n            }\n        }\n    }\n    else { // arraybuffer, uint8array, ...\n        o.base64 = false;\n        o.binary = true;\n\n        if (!dataType && !(data instanceof CompressedObject)) {\n            throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n        }\n\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = utils.transformTo(\"uint8array\", data);\n        }\n    }\n\n    var object = new ZipObject(name, data, o);\n    this.files[name] = object;\n    return object;\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) == '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) != \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : false;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {JSZip.CompressedObject} the compressed result.\n */\nvar generateCompressedObjectFrom = function(file, compression, compressionOptions) {\n    var result = new CompressedObject(),\n        content;\n\n    // the data has not been decompressed, we might reuse things !\n    if (file._data instanceof CompressedObject) {\n        result.uncompressedSize = file._data.uncompressedSize;\n        result.crc32 = file._data.crc32;\n\n        if (result.uncompressedSize === 0 || file.dir) {\n            compression = compressions['STORE'];\n            result.compressedContent = \"\";\n            result.crc32 = 0;\n        }\n        else if (file._data.compressionMethod === compression.magic) {\n            result.compressedContent = file._data.getCompressedContent();\n        }\n        else {\n            content = file._data.getContent();\n            // need to decompress / recompress\n            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n        }\n    }\n    else {\n        // have uncompressed data\n        content = getBinaryData(file);\n        if (!content || content.length === 0 || file.dir) {\n            compression = compressions['STORE'];\n            content = \"\";\n        }\n        result.uncompressedSize = content.length;\n        result.crc32 = crc32(content);\n        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n\n    result.compressedSize = result.compressedContent.length;\n    result.compressionMethod = compression.magic;\n\n    return result;\n};\n\n\n\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {object} the zip parts.\n */\nvar generateZipParts = function(name, file, compressedObject, offset, platform, encodeFileName) {\n    var data = compressedObject.compressedContent,\n        useCustomEncoding = encodeFileName !== utf8.utf8encode,\n        encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n        utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n        comment = file.comment || \"\",\n        encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n        utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n        useUTF8ForComment = utfEncodedComment.length !== comment.length,\n        o = file.options,\n        dosTime,\n        dosDate,\n        extraFields = \"\",\n        unicodePathExtraField = \"\",\n        unicodeCommentExtraField = \"\",\n        dir, date;\n\n\n    // handle the deprecated options.dir\n    if (file._initialMetadata.dir !== file.dir) {\n        dir = file.dir;\n    } else {\n        dir = o.dir;\n    }\n\n    // handle the deprecated options.date\n    if(file._initialMetadata.date !== file.date) {\n        date = file.date;\n    } else {\n        date = o.date;\n    }\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getSeconds() / 2;\n\n    dosDate = date.getFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(this.crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    // set bit 11 if utf8\n    header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\";\n    // compression method\n    header += compressedObject.compressionMethod;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(compressedObject.crc32, 4);\n    // compressed size\n    header += decToHex(compressedObject.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(compressedObject.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n    // version made by (00: DOS)\n    decToHex(versionMadeBy, 2) +\n    // file header (common to file and central directory)\n    header +\n    // file comment length\n    decToHex(encodedComment.length, 2) +\n    // disk number start\n    \"\\x00\\x00\" +\n    // internal file attributes TODO\n    \"\\x00\\x00\" +\n    // external file attributes\n    decToHex(extFileAttr, 4) +\n    // relative offset of local header\n    decToHex(offset, 4) +\n    // file name\n    encodedFileName +\n    // extra field\n    extraFields +\n    // file comment\n    encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord,\n        compressedObject: compressedObject\n    };\n};\n\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * Read an existing zip and merge the data in the current JSZip object.\n     * The implementation is in jszip-load.js, don't forget to include it.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n     * @param {Object} options Options for loading the stream.\n     *  options.base64 : is the stream in base64 ? default : false\n     * @return {JSZip} the current JSZip object\n     */\n    load: function(stream, options) {\n        throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [],\n            filename, relativePath, file, fileClone;\n        for (filename in this.files) {\n            file = this.files[filename];\n            // return a new object, don't let the user mess with our internal objects :)\n            fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (filename.slice(0, this.root.length) === this.root && // the file is in the current root\n            search(relativePath, fileClone)) { // and the file matches the function\n                result.push(fileClone);\n            }\n        }\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (utils.isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && relativePath === name;\n                })[0] || null;\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (utils.isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) != \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - base64, (deprecated, use type instead) true to generate base64.\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        options = utils.extend(options || {}, {\n            base64: true,\n            compression: \"STORE\",\n            compressionOptions : null,\n            type: \"base64\",\n            platform: \"DOS\",\n            comment: null,\n            mimeType: 'application/zip',\n            encodeFileName: utf8.utf8encode\n        });\n\n        utils.checkSupport(options.type);\n\n        // accept nodejs `process.platform`\n        if(\n          options.platform === 'darwin' ||\n          options.platform === 'freebsd' ||\n          options.platform === 'linux' ||\n          options.platform === 'sunos'\n        ) {\n          options.platform = \"UNIX\";\n        }\n        if (options.platform === 'win32') {\n          options.platform = \"DOS\";\n        }\n\n        var zipData = [],\n            localDirLength = 0,\n            centralDirLength = 0,\n            writer, i,\n            encodedComment = utils.transformTo(\"string\", options.encodeFileName(options.comment || this.comment || \"\"));\n\n        // first, generate all the zip parts.\n        for (var name in this.files) {\n            var file = this.files[name];\n\n            var compressionName = file.options.compression || options.compression.toUpperCase();\n            var compression = compressions[compressionName];\n            if (!compression) {\n                throw new Error(compressionName + \" is not a valid compression method !\");\n            }\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n\n            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n\n            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);\n            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n            centralDirLength += zipPart.dirRecord.length;\n            zipData.push(zipPart);\n        }\n\n        var dirEnd = \"\";\n\n        // end of central dir signature\n        dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(zipData.length, 2) +\n        // total number of entries in the central directory\n        decToHex(zipData.length, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n\n        // we have all the parts (and the total length)\n        // time to create a writer !\n        var typeName = options.type.toLowerCase();\n        if(typeName===\"uint8array\"||typeName===\"arraybuffer\"||typeName===\"blob\"||typeName===\"nodebuffer\") {\n            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n        }else{\n            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n        }\n\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].fileRecord);\n            writer.append(zipData[i].compressedObject.compressedContent);\n        }\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].dirRecord);\n        }\n\n        writer.append(dirEnd);\n\n        var zip = writer.finalize();\n\n\n\n        switch(options.type.toLowerCase()) {\n            // case \"zip is an Uint8Array\"\n            case \"uint8array\" :\n            case \"arraybuffer\" :\n            case \"nodebuffer\" :\n               return utils.transformTo(options.type.toLowerCase(), zip);\n            case \"blob\" :\n               return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip), options.mimeType);\n            // case \"zip is a string\"\n            case \"base64\" :\n               return (options.base64) ? base64.encode(zip) : zip;\n            default : // case \"string\" :\n               return zip;\n         }\n\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    crc32: function (input, crc) {\n        return crc32(input, crc);\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8encode: function (string) {\n        return utils.transformTo(\"string\", utf8.utf8encode(string));\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8decode: function (input) {\n        return utf8.utf8decode(input);\n    }\n};\nmodule.exports = out;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}