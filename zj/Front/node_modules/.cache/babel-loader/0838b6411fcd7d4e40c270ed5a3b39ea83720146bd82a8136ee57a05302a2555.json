{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodeBuffer = require('./nodeBuffer');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n  var buf,\n    c,\n    c2,\n    m_pos,\n    i,\n    str_len = str.length,\n    buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  if (support.uint8array) {\n    buf = new Uint8Array(buf_len);\n  } else {\n    buf = new Array(buf_len);\n  }\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n  return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function (buf, max) {\n  var pos;\n  max = max || buf.length;\n  if (max > buf.length) {\n    max = buf.length;\n  }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {\n    pos--;\n  }\n\n  // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) {\n    return max;\n  }\n\n  // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n  if (pos === 0) {\n    return max;\n  }\n  return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n  var str, i, out, c, c_len;\n  var len = buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) {\n      utf16buf[out++] = c;\n      continue;\n    }\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) {\n      utf16buf[out++] = 0xfffd;\n      i += c_len - 1;\n      continue;\n    }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = c << 6 | buf[i++] & 0x3f;\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) {\n      utf16buf[out++] = 0xfffd;\n      continue;\n    }\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n      utf16buf[out++] = 0xdc00 | c & 0x3ff;\n    }\n  }\n\n  // shrinkBuf(utf16buf, out)\n  if (utf16buf.length !== out) {\n    if (utf16buf.subarray) {\n      utf16buf = utf16buf.subarray(0, out);\n    } else {\n      utf16buf.length = out;\n    }\n  }\n\n  // return String.fromCharCode.apply(null, utf16buf);\n  return utils.applyFromCharCode(utf16buf);\n};\n\n// That's all for the pako functions.\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n  if (support.nodebuffer) {\n    return nodeBuffer(str, \"utf-8\");\n  }\n  return string2buf(str);\n};\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n  if (support.nodebuffer) {\n    return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n  }\n  buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n  // return buf2string(buf);\n  // Chrome prefers to work with \"small\" chunks of data\n  // for the method buf2string.\n  // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n  var result = [],\n    k = 0,\n    len = buf.length,\n    chunk = 65536;\n  while (k < len) {\n    var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n    if (support.uint8array) {\n      result.push(buf2string(buf.subarray(k, nextBoundary)));\n    } else {\n      result.push(buf2string(buf.slice(k, nextBoundary)));\n    }\n    k = nextBoundary;\n  }\n  return result.join(\"\");\n};\n// vim: set shiftwidth=4 softtabstop=4:","map":{"version":3,"names":["utils","require","support","nodeBuffer","_utf8len","Array","i","string2buf","str","buf","c","c2","m_pos","str_len","length","buf_len","charCodeAt","uint8array","Uint8Array","utf8border","max","pos","buf2string","out","c_len","len","utf16buf","subarray","applyFromCharCode","exports","utf8encode","nodebuffer","utf8decode","transformTo","toString","result","k","chunk","nextBoundary","Math","min","push","slice","join"],"sources":["/Users/jiezhou/IdeaProjects/graduaction/zj/Front/node_modules/jszip/lib/utf8.js"],"sourcesContent":["'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodeBuffer = require('./nodeBuffer');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodeBuffer(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    // return buf2string(buf);\n    // Chrome prefers to work with \"small\" chunks of data\n    // for the method buf2string.\n    // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n    var result = [], k = 0, len = buf.length, chunk = 65536;\n    while (k < len) {\n        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n        if (support.uint8array) {\n            result.push(buf2string(buf.subarray(k, nextBoundary)));\n        } else {\n            result.push(buf2string(buf.slice(k, nextBoundary)));\n        }\n        k = nextBoundary;\n    }\n    return result.join(\"\");\n\n};\n// vim: set shiftwidth=4 softtabstop=4:\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}