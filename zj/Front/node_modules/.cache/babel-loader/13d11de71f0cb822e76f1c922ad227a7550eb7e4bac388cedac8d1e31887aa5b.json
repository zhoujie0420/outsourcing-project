{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\nfunction DataReader(data) {\n  this.data = null; // type : see implementation\n  this.length = 0;\n  this.index = 0;\n  this.zero = 0;\n}\nDataReader.prototype = {\n  /**\n   * Check that the offset will not go too far.\n   * @param {string} offset the additional offset to check.\n   * @throws {Error} an Error if the offset is out of bounds.\n   */\n  checkOffset: function (offset) {\n    this.checkIndex(this.index + offset);\n  },\n  /**\n   * Check that the specifed index will not be too far.\n   * @param {string} newIndex the index to check.\n   * @throws {Error} an Error if the index is out of bounds.\n   */\n  checkIndex: function (newIndex) {\n    if (this.length < this.zero + newIndex || newIndex < 0) {\n      throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n    }\n  },\n  /**\n   * Change the index.\n   * @param {number} newIndex The new index.\n   * @throws {Error} if the new index is out of the data.\n   */\n  setIndex: function (newIndex) {\n    this.checkIndex(newIndex);\n    this.index = newIndex;\n  },\n  /**\n   * Skip the next n bytes.\n   * @param {number} n the number of bytes to skip.\n   * @throws {Error} if the new index is out of the data.\n   */\n  skip: function (n) {\n    this.setIndex(this.index + n);\n  },\n  /**\n   * Get the byte at the specified index.\n   * @param {number} i the index to use.\n   * @return {number} a byte.\n   */\n  byteAt: function (i) {\n    // see implementations\n  },\n  /**\n   * Get the next number with a given byte size.\n   * @param {number} size the number of bytes to read.\n   * @return {number} the corresponding number.\n   */\n  readInt: function (size) {\n    var result = 0,\n      i;\n    this.checkOffset(size);\n    for (i = this.index + size - 1; i >= this.index; i--) {\n      result = (result << 8) + this.byteAt(i);\n    }\n    this.index += size;\n    return result;\n  },\n  /**\n   * Get the next string with a given byte size.\n   * @param {number} size the number of bytes to read.\n   * @return {string} the corresponding string.\n   */\n  readString: function (size) {\n    return utils.transformTo(\"string\", this.readData(size));\n  },\n  /**\n   * Get raw data without conversion, <size> bytes.\n   * @param {number} size the number of bytes to read.\n   * @return {Object} the raw data, implementation specific.\n   */\n  readData: function (size) {\n    // see implementations\n  },\n  /**\n   * Find the last occurence of a zip signature (4 bytes).\n   * @param {string} sig the signature to find.\n   * @return {number} the index of the last occurence, -1 if not found.\n   */\n  lastIndexOfSignature: function (sig) {\n    // see implementations\n  },\n  /**\n   * Get the next date.\n   * @return {Date} the date.\n   */\n  readDate: function () {\n    var dostime = this.readInt(4);\n    return new Date((dostime >> 25 & 0x7f) + 1980,\n    // year\n    (dostime >> 21 & 0x0f) - 1,\n    // month\n    dostime >> 16 & 0x1f,\n    // day\n    dostime >> 11 & 0x1f,\n    // hour\n    dostime >> 5 & 0x3f,\n    // minute\n    (dostime & 0x1f) << 1); // second\n  }\n};\n\nmodule.exports = DataReader;","map":{"version":3,"names":["utils","require","DataReader","data","length","index","zero","prototype","checkOffset","offset","checkIndex","newIndex","Error","setIndex","skip","n","byteAt","i","readInt","size","result","readString","transformTo","readData","lastIndexOfSignature","sig","readDate","dostime","Date","module","exports"],"sources":["/Users/jiezhou/IdeaProjects/graduaction/zj/Front/node_modules/jszip/lib/dataReader.js"],"sourcesContent":["'use strict';\nvar utils = require('./utils');\n\nfunction DataReader(data) {\n    this.data = null; // type : see implementation\n    this.length = 0;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specifed index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1); // second\n    }\n};\nmodule.exports = DataReader;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}