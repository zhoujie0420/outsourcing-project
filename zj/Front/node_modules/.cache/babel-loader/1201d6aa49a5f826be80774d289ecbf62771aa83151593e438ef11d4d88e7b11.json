{"ast":null,"code":"import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [/*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n  label: \"function\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n  label: \"for\",\n  detail: \"of loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n  label: \"do\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n  label: \"while\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n  label: \"try\",\n  detail: \"/ catch block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n  label: \"if\",\n  detail: \"block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n  label: \"if\",\n  detail: \"/ else block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n  label: \"class\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"named\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n  label: \"import\",\n  detail: \"default\",\n  type: \"keyword\"\n})];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([/*@__PURE__*/snippetCompletion(\"interface ${name} {\\n\\t${}\\n}\", {\n  label: \"interface\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"type ${name} = ${type}\", {\n  label: \"type\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"enum ${name} {\\n\\t${}\\n}\", {\n  label: \"enum\",\n  detail: \"definition\",\n  type: \"keyword\"\n})]);\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\"Script\", \"Block\", \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\", \"ForStatement\"]);\nfunction defID(type) {\n  return (node, def) => {\n    let id = node.node.getChild(\"VariableDefinition\");\n    if (id) def(id, type);\n    return true;\n  };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n  FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n  ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n  ClassExpression: () => true,\n  EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n  TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n  NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n  VariableDefinition(node, def) {\n    if (!node.matchContext(functionContext)) def(node, \"variable\");\n  },\n  TypeDefinition(node, def) {\n    def(node, \"type\");\n  },\n  __proto__: null\n};\nfunction getScope(doc, node) {\n  let cached = cache.get(node);\n  if (cached) return cached;\n  let completions = [],\n    top = true;\n  function def(node, type) {\n    let name = doc.sliceString(node.from, node.to);\n    completions.push({\n      label: name,\n      type\n    });\n  }\n  node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n    if (top) {\n      top = false;\n    } else if (node.name) {\n      let gather = gatherCompletions[node.name];\n      if (gather && gather(node, def) || ScopeNodes.has(node.name)) return false;\n    } else if (node.to - node.from > 8192) {\n      // Allow caching for bigger internal nodes\n      for (let c of getScope(doc, node.node)) completions.push(c);\n      return false;\n    }\n  });\n  cache.set(node, completions);\n  return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"TemplateString\", \"String\", \"RegExp\", \"LineComment\", \"BlockComment\", \"VariableDefinition\", \"TypeDefinition\", \"Label\", \"PropertyDefinition\", \"PropertyName\", \"PrivatePropertyDefinition\", \"PrivatePropertyName\", \".\", \"?.\"];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (dontComplete.indexOf(inner.name) > -1) return null;\n  let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n  if (!isWord && !context.explicit) return null;\n  let options = [];\n  for (let pos = inner; pos; pos = pos.parent) {\n    if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n  }\n  return {\n    options,\n    from: isWord ? inner.from : context.pos,\n    validFor: Identifier\n  };\n}\nfunction pathFor(read, member, name) {\n  var _a;\n  let path = [];\n  for (;;) {\n    let obj = member.firstChild,\n      prop;\n    if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n      path.push(read(obj));\n      return {\n        path: path.reverse(),\n        name\n      };\n    } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = prop = obj.lastChild) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n      path.push(read(prop));\n      member = obj;\n    } else {\n      return null;\n    }\n  }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n  let read = node => context.state.doc.sliceString(node.from, node.to);\n  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (inner.name == \"PropertyName\") {\n    return pathFor(read, inner.parent, read(inner));\n  } else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n    return pathFor(read, inner.parent, \"\");\n  } else if (dontComplete.indexOf(inner.name) > -1) {\n    return null;\n  } else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n    return {\n      path: [],\n      name: read(inner)\n    };\n  } else if (inner.name == \"MemberExpression\") {\n    return pathFor(read, inner, \"\");\n  } else {\n    return context.explicit ? {\n      path: [],\n      name: \"\"\n    } : null;\n  }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n  let options = [],\n    seen = new Set();\n  for (let depth = 0;; depth++) {\n    for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n      if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name)) continue;\n      seen.add(name);\n      let value;\n      try {\n        value = obj[name];\n      } catch (_) {\n        continue;\n      }\n      options.push({\n        label: name,\n        type: typeof value == \"function\" ? /^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\" : top ? \"variable\" : \"property\",\n        boost: -depth\n      });\n    }\n    let next = Object.getPrototypeOf(obj);\n    if (!next) return options;\n    obj = next;\n  }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n  let cache = new Map();\n  return context => {\n    let path = completionPath(context);\n    if (!path) return null;\n    let target = scope;\n    for (let step of path.path) {\n      target = target[step];\n      if (!target) return null;\n    }\n    let options = cache.get(target);\n    if (!options) cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n    return {\n      from: context.pos - path.name.length,\n      options,\n      validFor: Identifier\n    };\n  };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"javascript\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      IfStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|else\\b)/\n      }),\n      TryStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|catch\\b|finally\\b)/\n      }),\n      LabeledStatement: flatIndent,\n      SwitchBody: context => {\n        let after = context.textAfter,\n          closed = /^\\s*\\}/.test(after),\n          isCase = /^\\s*(case|default)\\b/.test(after);\n        return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n      },\n      Block: /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      ArrowFunction: cx => cx.baseIndent + cx.unit,\n      \"TemplateString BlockComment\": () => null,\n      \"Statement Property\": /*@__PURE__*/continuedIndent({\n        except: /^{/\n      }),\n      JSXElement(context) {\n        let closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      JSXEscape(context) {\n        let closed = /\\s*\\}/.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      \"JSXOpenTag JSXSelfClosingTag\"(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n      BlockComment(tree) {\n        return {\n          from: tree.from + 2,\n          to: tree.to - 2\n        };\n      }\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"]\n    },\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n    wordChars: \"$\"\n  }\n});\nconst jsxSublanguage = {\n  test: node => /^JSX/.test(node.name),\n  facet: /*@__PURE__*/defineLanguageFacet({\n    commentTokens: {\n      block: {\n        open: \"{/*\",\n        close: \"*/}\"\n      }\n    }\n  })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"ts\"\n}, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx\",\n  props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n  dialect: \"jsx ts\",\n  props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nlet kwCompletion = name => ({\n  label: name,\n  type: \"keyword\"\n});\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat( /*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/\nfunction javascript(config = {}) {\n  let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;\n  let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n  return new LanguageSupport(lang, [javascriptLanguage.data.of({\n    autocomplete: ifNotIn(dontComplete, completeFromList(completions))\n  }), javascriptLanguage.data.of({\n    autocomplete: localCompletionSource\n  }), config.jsx ? autoCloseTags : []]);\n}\nfunction findOpenTag(node) {\n  for (;;) {\n    if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\") return node;\n    if (node.name == \"JSXEscape\" || !node.parent) return null;\n    node = node.parent;\n  }\n}\nfunction elementName(doc, tree, max = doc.length) {\n  for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n    if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" || ch.name == \"JSXMemberExpression\") return doc.sliceString(ch.from, Math.min(ch.to, max));\n  }\n  return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != \">\" && text != \"/\" || !javascriptLanguage.isActiveAt(view.state, from, -1)) return false;\n  let base = defaultInsert(),\n    {\n      state\n    } = base;\n  let closeTags = state.changeByRange(range => {\n    var _a;\n    let {\n        head\n      } = range,\n      around = syntaxTree(state).resolveInner(head - 1, -1),\n      name;\n    if (around.name == \"JSXStartTag\") around = around.parent;\n    if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n      return {\n        range,\n        changes: {\n          from: head,\n          insert: `</>`\n        }\n      };\n    } else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n      let empty = around.parent,\n        base = empty.parent;\n      if (base && empty.from == head - 2 && ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n        let insert = `${name}>`;\n        return {\n          range: EditorSelection.cursor(head + insert.length, -1),\n          changes: {\n            from: head,\n            insert\n          }\n        };\n      }\n    } else if (text == \">\") {\n      let openTag = findOpenTag(around);\n      if (openTag && openTag.name == \"JSXOpenTag\" && !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) && (name = elementName(state.doc, openTag, head))) return {\n        range,\n        changes: {\n          from: head,\n          insert: `</${name}>`\n        }\n      };\n    }\n    return {\n      range\n    };\n  });\n  if (closeTags.changes.empty) return false;\n  view.dispatch([base, state.update(closeTags, {\n    userEvent: \"input.complete\",\n    scrollIntoView: true\n  })]);\n  return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n  if (!config) {\n    config = {\n      parserOptions: {\n        ecmaVersion: 2019,\n        sourceType: \"module\"\n      },\n      env: {\n        browser: true,\n        node: true,\n        es6: true,\n        es2015: true,\n        es2017: true,\n        es2020: true\n      },\n      rules: {}\n    };\n    eslint.getRules().forEach((desc, name) => {\n      if (desc.meta.docs.recommended) config.rules[name] = 2;\n    });\n  }\n  return view => {\n    let {\n        state\n      } = view,\n      found = [];\n    for (let {\n      from,\n      to\n    } of javascriptLanguage.findRegions(state)) {\n      let fromLine = state.doc.lineAt(from),\n        offset = {\n          line: fromLine.number - 1,\n          col: from - fromLine.from,\n          pos: from\n        };\n      for (let d of eslint.verify(state.sliceDoc(from, to), config)) found.push(translateDiagnostic(d, state.doc, offset));\n    }\n    return found;\n  };\n}\nfunction mapPos(line, col, doc, offset) {\n  return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n  let start = mapPos(input.line, input.column, doc, offset);\n  let result = {\n    from: start,\n    to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n    message: input.message,\n    source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n    severity: input.severity == 1 ? \"warning\" : \"error\"\n  };\n  if (input.fix) {\n    let {\n        range,\n        text\n      } = input.fix,\n      from = range[0] + offset.pos - start,\n      to = range[1] + offset.pos - start;\n    result.actions = [{\n      name: \"fix\",\n      apply(view, start) {\n        view.dispatch({\n          changes: {\n            from: start + from,\n            to: start + to,\n            insert: text\n          },\n          scrollIntoView: true\n        });\n      }\n    }];\n  }\n  return result;\n}\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage, typescriptSnippets };","map":{"version":3,"names":["parser","syntaxTree","LRLanguage","indentNodeProp","continuedIndent","flatIndent","delimitedIndent","foldNodeProp","foldInside","defineLanguageFacet","sublanguageProp","LanguageSupport","EditorSelection","EditorView","snippetCompletion","ifNotIn","completeFromList","NodeWeakMap","IterMode","snippets","label","detail","type","typescriptSnippets","concat","cache","ScopeNodes","Set","defID","node","def","id","getChild","functionContext","gatherCompletions","FunctionDeclaration","ClassDeclaration","ClassExpression","EnumDeclaration","TypeAliasDeclaration","NamespaceDeclaration","VariableDefinition","matchContext","TypeDefinition","__proto__","getScope","doc","cached","get","completions","top","name","sliceString","from","to","push","cursor","IncludeAnonymous","iterate","gather","has","c","set","Identifier","dontComplete","localCompletionSource","context","inner","state","resolveInner","pos","indexOf","isWord","test","sliceDoc","explicit","options","parent","validFor","pathFor","read","member","_a","path","obj","firstChild","prop","reverse","lastChild","completionPath","enumeratePropertyCompletions","seen","depth","Object","getOwnPropertyNames","keys","add","value","_","boost","next","getPrototypeOf","scopeCompletionSource","scope","Map","target","step","length","javascriptLanguage","define","configure","props","IfStatement","except","TryStatement","LabeledStatement","SwitchBody","after","textAfter","closed","isCase","baseIndent","unit","Block","closing","ArrowFunction","cx","TemplateString BlockComment","JSXElement","lineIndent","JSXEscape","JSXOpenTag JSXSelfClosingTag","column","BlockComment","tree","languageData","closeBrackets","brackets","commentTokens","line","block","open","close","indentOnInput","wordChars","jsxSublanguage","facet","typescriptLanguage","dialect","jsxLanguage","n","isTop","undefined","tsxLanguage","kwCompletion","keywords","split","map","typescriptKeywords","javascript","config","lang","jsx","typescript","data","of","autocomplete","autoCloseTags","findOpenTag","elementName","max","ch","nextSibling","Math","min","android","navigator","userAgent","inputHandler","view","text","defaultInsert","composing","compositionStarted","readOnly","isActiveAt","base","closeTags","changeByRange","range","head","around","changes","insert","empty","openTag","dispatch","update","userEvent","scrollIntoView","esLint","eslint","parserOptions","ecmaVersion","sourceType","env","browser","es6","es2015","es2017","es2020","rules","getRules","forEach","desc","meta","docs","recommended","found","findRegions","fromLine","lineAt","offset","number","col","d","verify","translateDiagnostic","mapPos","input","start","result","endLine","endColumn","message","source","ruleId","severity","fix","actions","apply"],"sources":["/Users/jiezhou/IdeaProjects/graduaction/zj/Front/node_modules/@codemirror/lang-javascript/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([\n    /*@__PURE__*/snippetCompletion(\"interface ${name} {\\n\\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"enum ${name} {\\n\\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/continuedIndent({ except: /^{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nlet kwCompletion = (name) => ({ label: name, type: \"keyword\" });\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat(/*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: ifNotIn(dontComplete, completeFromList(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = syntaxTree(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range, changes: { from: head, insert: `</>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 &&\n                ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return { range: EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && openTag.name == \"JSXOpenTag\" &&\n                !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range, changes: { from: head, insert: `</${name}>` } };\n        }\n        return { range };\n    });\n    if (closeTags.changes.empty)\n        return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, { userEvent: \"input.complete\", scrollIntoView: true })\n    ]);\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            if (desc.meta.docs.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage, typescriptSnippets };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}